1.Angular：UI自动更新

2.ng-app

3.ng-model——双向绑定

4.{{}}——输出

5.Controller

app.controller('名字', function (){
	//controller的代码
});

filter-过滤器
	1.输出数据之前-处理一下
	2.参数
*********************************************************
自定义过滤器：
app.filter('名字', function (){
	//filter的代码
});


花了5块钱	-5
赚了100块钱	100

会计：
-5	->	(5)
+100	->	100

filter_name:参数

--------------------------------------------------------------------------------------------------------------------------------------

app.xxxx('名字', function (){
	干什么的代码
});

<span></span>

restrict
	E	Element		元素
	A	Attribute		属性
	C	Class			类
	M	Comment		注释
		*必须加上replace
		**必须两边空格

	abc
	<div abc=""></div>
		replace:false	<div abc=""><span>987654321</span></div>
		replace:true	<span>987654321</span>

*********************************************************

指令：增强HTML的功能

最简单的——指令出现在哪儿，模板的内容就到哪儿

transclude-嵌入、包裹
1.transclude: true
2.占位符——原始内容
	<ng-transclude></ng-transclude>

transclude：
1.标签	<ng-transclude></ng-transclude>
2.属性

*********************************************************

指令

app.directive('名字', function (){
	return {
		restrict: E/A/C/M		标签/属性/class/注释
		template: '插入的内容'
	};
});

<xxx></xxx>
<div xxx></div>
<div class="xxx"></div>
<!-- directive:xxx -->		replace:true

*********************************************************

指令——自定义组件(重用)
1.创建一堆元素
2.重用

*********************************************************

添加：controller、filter、directive

*********************************************************

app.directive('名字', function (){
	return {
		restrict: 'AEC',
		template: '插入的内容'
	};
});

<名字>
<div 名字>
<div class="名字">

指令命名只能用英文和数字,不能带符号(会报错) --  驼峰命名	myClose       ***

任何angularjs的代码中都可以用{{}}     ***
--------------------------------------------------------------------------------------------------------------------------------------

模块化：重用
1.按需加载、动态加载
2.封装、隔离
3.依赖

*********************************************************

1.定义模块
	var app=angular.module('名字', [依赖模块]);

	app.controller
	app.filter
	app.directive

2.使用(调用)模块
	<div ng-app="名字">

*********************************************************

1.angular也有模块
	模块身上有：Controller、Filter、Directive

2.angular模块依赖
	module('名字', [依赖的模块])

3.使用模块
	ng-app="名字"

angular.module('page1', ['commonFilter', 'commonDirective']);

*********************************************************
angular.module('名字', [])
.controller()
.filter();

1.页面引用
ng-app="名字"

2.模块依赖
angular.module('名字2', ['名字']);		//同名：后面的模块会覆盖前面的模块

--------------------------------------------------------------------------------------------------------------------------------------

$scope
$http
$interval
$timeout

自定义依赖注入——乱、多

创造依赖：
1.最简单——factory
	app.xxx('name', function (){})

	app.factory('sum', function (){
		return 内容;
	});

2.强大——provider
	provider提供东西的
	app.provider('name', function (){
		this.$get=function (){
		};
	});

	//factory：
	app.factory()->1个
	app.factory()->2个

	//angular会：
	var pro=new provider();	//
	pro.$get()->1个
	pro.$get()->2个

3.服务——service
	


factory——简单
app.factory(xx, function (){
	return {...};
});

provider——强大：可配置的
app.provider(xx, function (){
	this.$get=function (){
		return {...};
	};
});

service——类似于构造函数
app.service(xx, function (){
	this.xxx
});

4.constant——常量(不可装饰)

5.value——变量

*********************************************************

修改依赖
*会修改原始的依赖，原来的依赖就变了

app.decorator('依赖的名字', function ($delegate){
	$delegate	依赖项的东西(是指被修改的对象，不是继承，因为会修改父类，真正的继承不会)

	return 修改后的依赖;
});

主要用于 -- 修改网上托管的代码，以防网上托管的代码更新以后造成影响。如果是自己的代码，那么建议直接修改源码，不用这个，以防太乱

*********************************************************

1.创造依赖项
	factory：简单
	provider：可配置
	service：类似构造函数
	constant：常量-不可修饰
	value：变量

2.修改现有的依赖
	app.decorator(依赖的名字, function ($delegate){
		$delegate——原始的依赖
		return 修饰过的;
	});

所有依赖项只会创建一次 —— 好事：依赖项的状态在不同的地方是共享的    ***

*********************************************************

数据共享——多个Controller之间
1.父子Controller
$scope能继承——复制了$scope
	*不能叫同步，只是创建controller的时候复制了一份（在子级改变父级不跟着变，父级改变同理）

消息机制(事件)：   //只能工作在父子级的controller中（因为只有父子级的controller才共用一个$scope）
	$scope.$emit('名字', 数据);	触发：自己+父级，向上发送
	$scope.$broadcast('名字', 数据);	触发：自己+子级，向下发送
	$scope.$on('名字', 数据);		接收

    //注意执行顺序，通过事件触发比较好      ***

2.无关Controller
用自定义依赖来存储数据
	*factory、service、provider——创建的依赖只有一个

不推荐的做法：
    1.$scoperoot全局
    2.写在一个controller里   太乱
--------------------------------------------------------------------------------------------------------------------------------------

Router——多视图
	*根据URL来切换视图

例子：用户信息+文章列表+文章详情页面+配置页面

*********************************************************

引入Route
1.引入文件
	<script src="js/angular-route.js"></script>

2.引入ngRoute模块
	var app=angular.module('test', ["ngRoute"]);

*********************************************************

Router：根据地址的不同会显示不同内容
1.引入文件
	<script>
	module('xx', ['ngRoute'])

2.配置route
	app.config(function ($routeProvider){
		$routeProvider.when(
			'地址',
			{配置信息}
		);
	});

	template: ''

*********************************************************

promise请求序列化

1.请求数据
2.过滤
3.展现

ajax('...', {success: function (){
	for(var if...
	ajax('...', function (){
		xxxx
		ajax
	});
}});

promise.then().then().then();

*********************************************************

Route：分离多视图、多Controller
1.引入
	<script>
	module('xxx', ['ngRoute'])

2.配置
	app.config(function ($routeProvider){
		$routeProvider
		.when(
			地址,
			{
				templateUrl: 'view地址',
				controller: 'controller名字'
			}
		);
	});

*********************************************************

模板：
1.template
	template: '模板HTML'

2.templateUrl
	templateUrl: './views/xxx.html'

3.ng-template
	<script type="text/ng-template" id="ID">
		模板内容
	</script>

	templateUrl: 'ID'

--------------------------------------------------------------------------------------------------------------------------------------

controller
	数据操作

filter
	过滤：文字处理

directive
	表现层的组件(选项卡、显示更多)

route
	分离视图、控制器

Module











